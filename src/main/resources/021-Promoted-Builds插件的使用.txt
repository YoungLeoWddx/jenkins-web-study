1，对于Promoted Builds的解释。
	这个插件的功能并不是很好理解，这个插件允许您通过引入Promoted（提升）的概念来区分好的构建和坏的构建。简单地说，
	Promoted的构建是一个成功的构建，它通过了额外的标准（例如设置为下游构建作业的更全面的测试）。 使用Promoted的典型情
	况是将多个“测试”作业挂接为“该构建”作业的下游作业。档所有的下游构建作用成功通过之后，本构建就被提升啦。也就是是get promoted。
	
	还有可以指定什么用户触发的手工构建可以被认为是一个promoted Builds，比如技术总监执行的手工构建被认为是promoted构建。手工
	提升为promoted builds的时候可以输入构建参数。
	
	每一个get promoted的构建可以触发一个或者多个action。
	
2，为什么要用这样的机制来保证构建的promoted呢？
	我们知道，提交构建中，只是运行了项目的编译和单元测试和少部分的集成测试。提交构建一般都很快速，但是提交构建成功并不意味着提交构建是一个
	good构建还是一个bad构建。因为我们代码审查，测试，集成测试，系统测试，验收测试还没有通过呢，只有当所有的下游被触发的一些测试构建都通过了，那么，
	通过下游测试构建的hook机制，可以对上游构建进行promote提升。
	
	也有可能基于一些外部因素，我们可以指定一个高级别的用户来进行手工构建，只要构建人是此人，那么我们就认为该次构建就是一个promoted的完美构建啦，
	这个时候，高级别用户还可以输入一些构建参数，就可以触发一个或者多个action。
	
	
3， 在更复杂的情况下，可以设置多个级别的promoted，我们可以设置多个并列的Promotion process。 这很适合在有多个测试阶段的环境中（例如QA测试，
验收测试，分期和生产）。比如QA测试成功了的promoted构建触发进行一个指定的action，QA和验收测试都通过的promoted构建触发进行另外一个指定的action。


4，被promoted的构建触发的一般来说需要把生成的构建部署到测试服务器，部署环境中去。等这样的操作。但是有一点特别要值得注意，就是promoted的构建触发的action
是以当前工作空间为action的工作空间的，因此被触发的action的执行很有可能和该外层作业的正常执行发生冲突。
怎么理解这个过程呢？举个例子，现在有一个正常的提交构建a#1，完成之后，触发了自动化测试构建b，当自动化测试通过的时候，对a#1进行promote，a#1被promote的时候，、
触发了将war包发布到测试服务器的一个action，假如a#1构建并没有生成war的产物归档，而是在这个action中来生成war包，这是有风险的，因为提交构建很有可能现在正在
进行a#2的提交构建，已经把当前工作空间的内容修改了，生成的war包也不是a#1的代码生成的，这具有极大的风险，归根结底就是因为a的提交构建和promoted的action都共用
一个工作空间，会发生干扰。正确的做法是在a的每一次提交构建都生成构建产物，然后promoted的action中触发一个新的部署构建作业，将a#1的构建产物复制到新的部署构建作业
的工作空间中去。


5，关于构建物指纹的请看jenkins权威指南316页。通过promoted触发的action中，copy artifact需要指定permalink，这个需要注意。jenkins权威指南318页。

6，Promotion构建的使用场景：
	1，持久化构建物：您可能不想在每个版本上将工件推送到您的主要工件存储库。 通过构建Promotion，只有当工件符合某些标准时，才能推送。 例如，您可能只想在运行集成测试后推送它。
	2，特定人工执行构建被认为是Promotion，这样提供更大的灵活性。